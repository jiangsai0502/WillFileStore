window.ydoc_plugin_search_json = {
  "社畜进阶": [
    {
      "title": "",
      "content": "本书记录些计算机相关教程",
      "url": "/RoadToExcellence/index.html",
      "children": []
    },
    {
      "title": "YDoc系统搭建",
      "content": "",
      "url": "/RoadToExcellence/YDocBuild.html",
      "children": [
        {
          "title": "1.环境搭建",
          "url": "/RoadToExcellence/YDocBuild.html#1.环境搭建",
          "content": "1.环境搭建详细请参照帮助文档\n简易教程如下安装node.js：brew install node\n安装ydoc：npm install -g ydoc\n创建YDoc目录：mkdir ~/Documents/MyYDoc && cd ~/Documents/MyYDoc\n安装rc版本：npm install ydoc@rc\n\n在当前目录生成一个 'node_modules' 目录和package-lock.json文件\n\n\n创建站点目录：mkdir AgileDoc && cd AgileDoc\n初始化：ydoc init\n\n在当前目录生成一个 'docs' 目录，用于存放文档(markdown)文件\n\n\n构建：ydoc build\n\n使用 'docs' 目录中的文件进行文档站的构建，构建成功后会在当前目录生成一个 '_site' 目录，打开 '_site' 目录中的 index.html 文件即可访问构建的文档站首页\n\n\n启动服务：ydoc serve\n\n启动一个服务，默认是http://127.0.0.1:9999。修改docs目录下的文档，可以实时在http://127.0.0.1:9999看到变化\n\n\n安装插件\n\n插件网址：https://hellosean1025.github.io/ydoc/plugin/index.html\n安装点击图片放大功能的插件：npm i ydoc-plugin-img-view\n在 'docs' 和 '_site' 同级目录下创建ydoc.js文件\n{\n  \"plugins\": [\"img-view\"]\n}\n\n\n\n"
        },
        {
          "title": "2.系统目录结构",
          "url": "/RoadToExcellence/YDocBuild.html#2.系统目录结构",
          "content": "2.系统目录结构一个基本的 ydoc 目录结构如下:├── docs/    ├── index.jsx\n    ├── NAV.md\n    ├── book-1/\n        ├── index.md\n        └── SUMMARY.md\n    └── book-2/\n        ├── index.md\n        ├── SUMMARY.md\n\n\n文件\n描述\n\n\n\n\nindex.jsx\n首页 (必需)\n\n\nNAV.md\n导航) (必需)\n\n\nbook/index.md\n文档页首页] (必需)\n\n\nbook/SUMMARY.md\n文档目录，SUMMARY.md 引用的所有 markdown 文件将会被转换成 html 文件 (可选)\n\n\n所有的目录名称都必须是英文，包括各个文件名，想要在网页上显示中文名，要配置每个目录中的SUMMARY.md\n注：NAV.md 和 SUMMARY.md 文件名大写\n"
        },
        {
          "title": "3.顶端导航",
          "url": "/RoadToExcellence/YDocBuild.html#3.顶端导航",
          "content": "3.顶端导航在 NAV.md \b文件中可配置网站的顶端导航标题、logo、菜单列表信息，简单示例如下：# YDoc![logo](ydoc/images/logo.png)\n\n* [文档](/documents/index.md)\n* [文档规范](/style-guide/index.md)\n* [插件](/plugins/index.md)\n上面的 markdown 内容可生成如下导航信息：标题：YDocLogo：ydoc/images/logo.png\n导航：文档 文档规范 插件\n"
        },
        {
          "title": "4.首页",
          "url": "/RoadToExcellence/YDocBuild.html#4.首页",
          "content": "4.首页执行 init 命令后生产 docs 目录中的 index.jsx 就是首页的文档文件，在这个文件中我们可以通过简单的配置来完善首页信息：banner 网站标语栏\n\n\n属性\n描述\n\n\n\n\nname\n标语标题\n\n\ndesc\n标语描述信息\n\n\nbtns\n按钮组，可设置多个按钮\n\n\ncaption\n说明信息，例如“当前版本信息”\n\n\nbtns[n].name\n按钮名称\n\n\nbtns[n].href\n按钮链接\n\n\nbtns[n].primary\n是否为主按钮\n\n\nfeatures 特性\n\n\n属性\n描述\n\n\n\n\nfeatures[n].name\n特性名称\n\n\nfeatures[n].desc\n特性描述\n\n\nfooter 底部信息\n\n\n属性\n描述\n\n\n\n\ncopyRight\n版权信息\n\n\ncopyRight.name\n版权主体名称\n\n\ncopyRight.href\n版权主体链接\n\n\nlinks\n友情链接\n\n\nlinks.xxx\n链接组标题\n\n\nlinks.xxx[n]\n链接项\n\n\nlinks.xxx[n].name\n链接项名称\n\n\nlinks.xxx[n].href\n链接项名称\n\n\n"
        },
        {
          "title": "5.文档页",
          "url": "/RoadToExcellence/YDocBuild.html#5.文档页",
          "content": "5.文档页YDoc 借鉴了 Gitbook 中 \"书\" 的概念：YDoc 的每个导航项都是不同的 \"书\"\n每本 \"书\" 都是由目录和页面组成\nYDoc 文档站就是由若干本书及其他页面组成的网站\n使用 SUMMARY.md 文件生成一本书的目录，SUMMARY 文件包含了一本书的所有章节信息，具体的文档页面是若干 markdown 文件SUMMARY.md 由一组链接列表组成，将一个列表嵌套到父章节将创建子章节，简单示例如下：# 目录\n### 章节 1\n\n* [快速开始](start.md)\n  * [安装](installation.md)\n* [项目设置](setting.md)\n  * [配置文件](config.md)\n锚点\n\n目录中的章节可以使用锚点指向文件的特定部分。\n\n\n# 目录\n### 章节 2\n\n* [API](api.md)\n  * [a](api.md#anchor1)\n  * [b](api.md#anchor2)\n章节\n\n目录可以分为多个部分，如下所示：\n\n\n# 目录\n### 章节 1\n\n* [快速开始](start.md)\n  * [安装](installation.md)\n* [项目设置](setting.md)\n  * [配置文件](config.md)\n\n### 章节 2\n\n* [API](api.md)\n  * [a](api.md#a)\n  * [b](api.md#b)\n\n"
        }
      ]
    },
    {
      "title": "Markdown基本语法一级标题",
      "content": "",
      "url": "/RoadToExcellence/MarkdownUsage.html",
      "children": [
        {
          "title": "1.标题",
          "url": "/RoadToExcellence/MarkdownUsage.html#1.标题",
          "content": "1.标题使用#，可表示1-6级标题。# 一级标题\n## 二级标题\n### 三级标题\n#### 四级标题\n##### 五级标题\n###### 六级标题\n效果：一级标题\n二级标题\n三级标题\n四级标题\n五级标题\n六级标题\n"
        },
        {
          "title": "2.段落",
          "url": "/RoadToExcellence/MarkdownUsage.html#二级标题-2.段落",
          "content": "2.段落段落的前后要有空行。若想在段内强制换行的方式是使用两个以上空格加上回车（引用中换行省略回车）"
        },
        {
          "title": "3.反斜杠\\",
          "url": "/RoadToExcellence/MarkdownUsage.html#二级标题-3.反斜杠\\",
          "content": "3.反斜杠\\相当于反转义作用。使符号成为普通符号。"
        },
        {
          "title": "4.符号'`'：起到标记作用",
          "url": "/RoadToExcellence/MarkdownUsage.html#二级标题-4.符号'`'：起到标记作用",
          "content": "4.符号'`'：起到标记作用示例`ctrl+a`\n效果：ctrl+a\n"
        },
        {
          "title": "5.字体",
          "url": "/RoadToExcellence/MarkdownUsage.html#二级标题-5.字体",
          "content": "5.字体示例*斜体*\n**粗体**\n***粗体***\n效果斜体\n加粗\n斜体加粗\n"
        },
        {
          "title": "6.引用",
          "url": "/RoadToExcellence/MarkdownUsage.html#二级标题-6.引用",
          "content": "6.引用示例> 区块引用\n>> 嵌套引用\n效果区块引用\n\n嵌套引用\n\n"
        },
        {
          "title": "7.分割线",
          "url": "/RoadToExcellence/MarkdownUsage.html#二级标题-7.分割线",
          "content": "7.分割线示例---\n***\n效果\n\n"
        },
        {
          "title": "8.代码块",
          "url": "/RoadToExcellence/MarkdownUsage.html#二级标题-8.代码块",
          "content": "8.代码块单行代码： 代码两边分别用一个反引号包起来`代码内容`\n多行代码： 代码两边分别用三个反引号包起来，且两边的反引号单独占一行```\n代码块\n```\n"
        },
        {
          "title": "9.列表",
          "url": "/RoadToExcellence/MarkdownUsage.html#二级标题-9.列表",
          "content": "9.列表无序列表示例-（+*） 第一项\n-（+*） 第二项\n效果\n第一项\n第二项\n\n有序列表示例\n第一项\n第二项\n\n效果\n第一项\n第二项\n\n列表嵌套： 缩进3个空格示例* 第一项  \n   * 第一项第一层  \n1. 第一项\n   1. 第一项第一层 \n\n效果\n第一项\n\n第一项第一层\n\n\n\n\n第一项\n\n第一项第一层\n\n\n\n"
        },
        {
          "title": "10.超链接",
          "url": "/RoadToExcellence/MarkdownUsage.html#二级标题-10.超链接",
          "content": "10.超链接示例[链接名](http://baidu.com \"链接title\")。\n链接title可加可不加\n效果百度\n"
        },
        {
          "title": "11.图片",
          "url": "/RoadToExcellence/MarkdownUsage.html#二级标题-11.图片",
          "content": "11.图片语法![图片名](图片地址 \"图片title\")\ntitle可加可不加\n注意：只能用线上图片，不能用网络图片，所以可以使用企业云盘的图床https://ecloud.baidu.com/openapi/tuchuang，会自动生成一个永久图片链接\n\n示例![图片](http://bj.bcebos.com/ibox-thumbnail98/f6833abe678aa85f4976d60fd9a660b0?authorization=bce-auth-v1%2Ffbe74140929444858491fbf2b6bc0935%2F2020-01-06T10%3A07%3A05Z%2F1800%2F%2F59ba33c58680aafca3776d4982ee97cb89b6a00f92de355a6a817809923ee987)\n\n效果如下\n"
        },
        {
          "title": "12.表格",
          "url": "/RoadToExcellence/MarkdownUsage.html#二级标题-12.表格",
          "content": "12.表格示例| 左对齐 |  居中  | 右对齐 | :---- | :---: | ----: |\n| aaaa | bbbbbb | ccccc |\n| a    | b      | c     |\n效果如下：\n\n左对齐\n居中\n右对齐\n\n\n\n\naaaa\nbbbbbb\nccccc\n\n\na\nb\nc\n\n\n"
        },
        {
          "title": "13.音频",
          "url": "/RoadToExcellence/MarkdownUsage.html#二级标题-13.音频",
          "content": "13.音频语法\n"
        },
        {
          "title": "14.视频",
          "url": "/RoadToExcellence/MarkdownUsage.html#二级标题-14.视频",
          "content": "14.视频视频存放在agroup上语法1（用的是这个）\n\n语法2"
        }
      ]
    },
    {
      "title": "PicGo+GitHub 搭建图床",
      "content": "讲剪切板上的截图发送到图床，生成在线的图片链接\n",
      "url": "/RoadToExcellence/PicGo_GitHub.html",
      "children": [
        {
          "title": "创建自己的GitHub图床",
          "url": "/RoadToExcellence/PicGo_GitHub.html#创建自己的github图床",
          "content": "创建自己的GitHub图床登陆GitHub\n创建Repository\n\n点击\"New repository\"按钮\n\n按照1234步骤执行，建立一个名为Figurebed的repository\n3.生成一个Token用于操作GitHub repository回到主页，点击\"Settings\"按钮\n\n进入页面后，点击\"Developer settings\"按钮\n\n点击\"Personal access tokens\"按钮\n\n点击\"Generate new token\"按钮\n\n填写描述，选择\"repo\",然后点击\"Generate token\"按钮\n注：创建成功后，会生成一串token，这串token之后不会再显示，所以第一次看到的时候，就要好好保存\n"
        },
        {
          "title": "配置PicGo",
          "url": "/RoadToExcellence/PicGo_GitHub.html#配置picgo",
          "content": "配置PicGo\n下载运行PicGo\n\n\n\n配置图床\n\n\n\n设定仓库名的时候，是按照“账户名/仓库名”的格式填写\n\n如 jiangsai0502/PicBedRepo\n\n\n分支名统一填写“master”\n将之前的Token黏贴在这里\n存储路径可以写成img/，这样会在repository下创建一个“img”文件夹\n自定义域名的作用是，在上传图片后成功后，PicGo会将“自定义域名+上传的图片名”生成的访问链接，放到剪切板上https://raw.githubusercontent.com/账户名/仓库名/分支名，自定义域名需要按照这样去填写\n\n如https://raw.githubusercontent.com/jiangsai0502/PicBedRepo/master\n\n\n\n快捷键及相关配置\n可将快捷键设置为cmd+2\n"
        },
        {
          "title": "总结",
          "url": "/RoadToExcellence/PicGo_GitHub.html#总结",
          "content": "总结将上面的步骤都设置好之后，每次截图之后，都可以按一下cmd+2，这样就会将剪切板上面的截图转化为在线网络图片链接，爽"
        }
      ]
    },
    {
      "title": "重装系统",
      "content": "Finder顶端显示完整路径\ndefaults write com.apple.finder _FXShowPosixPathInTitle -bool YES\n启动台图标数量defaults write com.apple.dock springboard-rows -int 7\ndefaults write com.apple.dock springboard-columns -int 11\ndefaults write com.apple.dock ResetLaunchPad -bool true;killall Dock\n\n\nsougou\n微信\nChrome\nistat menus\nitsycal\nPaste（官网下载helper）\nsublime\nSnagit\nsnipaste\nbettertouchtool\nPDF expert\noffice\ngo2shell（官网下载）\n百度云盘\nMweb\nPicgo\nPermute\nParallels Desktop\nstretchly\nQQ\n欧路\nScreenFlow\nxcode\nAxure\nAppcleaner\nbrew\nyoutube-dl\nbrew install youtube-dl\nyou-get\nbrew install you-get\nstretchly\nbrew cask install stretchly\nmpv\nbrew cask install mpv\n\n创建配置文件：~/.config/mpv/input.conf\n\n\n\nAXIS_UP  add volume 2AXIS_DOWN  add volume -2\nAXIS_LEFT  seek -2 exact\nAXIS_RIGHT seek 2 exact\nLEFT  seek -2 exact\nRIGHT  seek 2 exact\nUP  add volume 2\nDOWN  add volume -2\n```\niterm2\nbrew cask install iterm2\n\n打开iterm2配置页\nopen -a Go2Shell --args config\n安装Oh my zsh\nsh -c \"$(curl -fsSL https://raw.github.com/robbyrussell/oh-my-zsh/master/tools/install.sh)\"\n安装PowerLine\n\nsudo easy_install pip\npip install powerline-status --user\n\n\n安装PowerFonts字体\n\nmkdir ~/Documents/Temp\ngit clone https://github.com/powerline/fonts.git --depth=1\n./fonts/install.sh\n\n设置字体：iTerm2 -> Preferences -> Profiles -> Text，在Font区域选中Change Font，然后找到Meslo LG字体，有L、M、S可选\n\n\n安装配色方案1\n\ncd ~/Documents/Temp\ngit clone https://github.com/altercation/solarized/ --config http.proxy='http://127.0.0.1:1087'\ncd solarized/iterm2-colors-solarized/\nopen solarized/iterm2-colors-solarized/\n\n设置配色：iTerm2 -> Preferences -> Profiles -> Colors -> Color Presets\n\n\n修改主题\n\ncd ~/Documents/Temp\ngit clone https://github.com/fcamblor/oh-my-zsh-agnoster-fcamblor.git --config http.proxy='http://127.0.0.1:1087'\n./oh-my-zsh-agnoster-fcamblor/install\nopen ~/.zshrc\n搜索'ZSH_THEME'，修改为ZSH_THEME=\"agnoster\"\n----或者使用自己的主题----\nhttps://github.com/jiangsai0502/WillFileStore\n1.把主题文件WillTheme.zsh-theme放入/Users/sai/.oh-my-zsh/themes\n2.open ~/.zshrc\n3.修改ZSH_THEME=\"WillTheme\"\n\n\n安装高亮插件\n\nbrew install zsh-syntax-highlighting\nopen ~/.zshrc\n最后插入一行：source /usr/local/share/zsh-syntax-highlighting/zsh-syntax-highlighting.zsh\nsource ~/.zshrc\n\n\n自动提示与命令补全\n\ncd ~/.oh-my-zsh/custom/plugins/\ngit clone https://github.com/zsh-users/zsh-autosuggestions  --config http.proxy='http://127.0.0.1:1087'\nopen ~/.zshrc\n搜索'plugins'，修改为plugins=(zsh-autosuggestions git)\n\n\n",
      "url": "/RoadToExcellence/ReinstallSystem.html",
      "children": [
        {
          "title": "you-get用法",
          "url": "/RoadToExcellence/ReinstallSystem.html#you-get用法",
          "content": "you-get用法分析视频可供下载的全部格式：-i参数\nyou-get -i 'https://www.youtube.com/watch?v=jNQXAC9IVRw'\n直接下载默认格式：\nyou-get 'https://www.youtube.com/watch?v=jNQXAC9IVRw'\n自定义下载格式：\nyou-get --itag=18 'https://www.youtube.com/watch?v=jNQXAC9IVRw'\n使用HTTP代理下载：\nyou-get -x 127.0.0.1:1087 'https://www.youtube.com/watch?v=jNQXAC9IVRw'\n"
        },
        {
          "title": "youtube-dl用法",
          "url": "/RoadToExcellence/ReinstallSystem.html#youtube-dl用法",
          "content": "youtube-dl用法下载默认类型视频（无字幕）\nyoutube-dl https://www.youtube.com/watch?v=n_6p-1J551Y\n下载默认类型视频（有字幕）\nyoutube-dl --write-auto-sub https://www.youtube.com/watch?v=n_6p-1J551Y\n下载字幕（无视频）\nyoutube-dl --write-auto-sub --skip-download https://www.youtube.com/watch?v=n_6p-1J551Y\n查看视频所有类型\nyoutube-dl -F https://www.youtube.com/watch?v=n_6p-1J551Y\n查看视频所有字幕\n-dl --list-subs https://www.youtube.com/watch?v=n_6p-1J551Y\n下载指定质量的视频和音频并自动合并（有字幕）\nyoutube-dl --write-auto-sub -f 160+249 https://www.youtube.com/watch?v=n_6p-1J551Y\n使用代理下载默认类型的视频（有字幕）\nyoutube-dl --proxy 127.0.0.1:1087 --write-auto-sub https://www.youtube.com/watch?v=xqdI6ljJ954\n获取proxy_url:proxy_port的方式\n在Shadowsocks找到copy HTTP proxy shell export line，如‘export http_proxy=http://127.0.0.1:1087’即可提取代理地址何端口\n"
        },
        {
          "title": "Mac 修改文件创建时间",
          "url": "/RoadToExcellence/ReinstallSystem.html#mac-修改文件创建时间",
          "content": "Mac 修改文件创建时间touch -mt YYYYMMDDhhmm示例1. 在Terminal中输入 touch -mt 20160101  2. 将/Users/will/Downloads/1.png拖入Terminal中\n3. Terminal会显示 touch -mt 20160101 /Users/will/Downloads/123.png\n4. 回车执行即可\n注：改成当天 touch -m 文件名\n"
        },
        {
          "title": "Git挂代理方式",
          "url": "/RoadToExcellence/ReinstallSystem.html#git挂代理方式",
          "content": "Git挂代理方式git clone https://github.com/altercation/solarized/ --config http.proxy='http://127.0.0.1:1087'"
        },
        {
          "title": "brew挂代理方式",
          "url": "/RoadToExcellence/ReinstallSystem.html#brew挂代理方式",
          "content": "brew挂代理方式touch ~/.curlrcopen ~/.curlrc\n输入代理地址：proxy=127.0.0.1:8087\n用完可以删掉该文件，否则墙内资源会受限\nrm ~/.curlrc\n"
        }
      ]
    },
    {
      "title": "搭建Python环境",
      "content": "",
      "url": "/RoadToExcellence/PythonEnvironment.html",
      "children": [
        {
          "title": "Anaconda",
          "url": "/RoadToExcellence/PythonEnvironment.html#anaconda",
          "content": "Anaconda"
        },
        {
          "title": "搭建环境",
          "url": "/RoadToExcellence/PythonEnvironment.html#anaconda-搭建环境",
          "content": "搭建环境官网下载后默认安装即可\n搜索anaconda3，得知安装路径是/opt/anaconda3\n在环境变量中添加anaconda3的路径\n\nopen ~/.bash_profile\n在最后插入一行：export PATH=\"/opt/anaconda3/bin:$PATH\"\nsource ~/.bash_profile\n\n\n\n在oh-my-zsh中添加anaconda3的路径\n\nopen ~/.zshrc\n在第三行插入一行：export PATH=\"/opt/anaconda3/bin:$PATH\"\nsource ~/.zshrc\n\n\n\n给conda挂代理\n\nopen ~/.condarc\n最后插入几行\nproxy_servers:\n  http: http://127.0.0.1:1087\n  https: https://127.0.0.1:1087\n\n\n\n"
        },
        {
          "title": "基础用法",
          "url": "/RoadToExcellence/PythonEnvironment.html#anaconda-基础用法",
          "content": "基础用法\n查看当前系统下的虚拟环境\n\nconda info --envs\n\n\n\n\n激活base虚拟环境(base是默认创建的)\n\nsource activate base\n\n\n\n\n退出虚拟环境\n\nconda deactivate\n\n\n\n\n创建名为jspython2 的python2.7的虚拟环境\n\nconda create -n jspython2 python=2.7\n\n\n\n\n创建名为jspython3 的python3.7的虚拟环境\n\nconda create -n jspython3 python=3.7\n\n\n\n\n虚拟环境的安装路径\n\n/Users/jiangsai02/opt/anaconda3/envs\n\n\n\n激活虚拟环境 jspython3\n\nsource activate jspython3\n\n\n\n\n切换虚拟环境 jspython3 到flask_py3\n\nconda deactivate\nsource activate flask_py3\n\n\n\n\n删除虚拟环境 jspython3\n\nconda env remove -n jspython3\n\n\n\n\n为当前的虚拟环境 flask_py3 安装flask包\n\nconda install flask\n\n\n\n\n虚拟环境下包的安装路径\n\n/Users/jiangsai02/opt/anaconda3/envs/flask_py3/lib/python3.7/site-packages/flask\n\n\n\n为当前的虚拟环境 flask_py3 更新flask包\n\nconda update flask\n\n\n\n\n为当前的虚拟环境 flask_py3 卸载flask包\n\nconda remove flask\n\n\n\n\n查看当前的虚拟环境 flask_py3 的所有安装包\n\nconda list\n\n\n\n"
        },
        {
          "title": "VSCode配置",
          "url": "/RoadToExcellence/PythonEnvironment.html#vscode配置",
          "content": "VSCode配置\n左侧最下方“Extensions”，安装以下插件\n\nPython - 代码分析，高亮，规范化\nBracket Pair Colorizer - 括号颜色\nAnaconda Extension Pack - 代码提示增强\nPython Extension Pack(Don Jayamanne) - 代码补全\n\n\n\n查看Python版本路径\n\nwhich python\n   /Users/jiangsai02/opt/anaconda3/bin/python\nwhich python3\n   /Users/jiangsai02/opt/anaconda3/bin/python3\n\n\n\n\n配置VS Code中用户配置\n\ncode - preference - settings，点击右上角的open settings(UI)，输入\n{\n    \"python.pythonPath\": \"/Users/jiangsai02/opt/anaconda3/envs/jspython3/bin/python\",\n    \"workbench.startupEditor\": \"newUntitledFile\",\n    \"terminal.integrated.inheritEnv\": false,\n    \"editor.minimap.enabled\": false,\n    \"editor.suggestSelection\": \"first\",\n    \"vsintellicode.modify.editor.suggestSelection\": \"automaticallyOverrodeDefaultValue\",\n    \"python.jediEnabled\": false,\n    \"terminal.integrated.shell.osx\": \"/bin/zsh\",\n    \"editor.renderControlCharacters\": true,\n    \"editor.renderWhitespace\": \"all\",\n}\n\n注：每次更换版本都要改python.pythonPath\n\n\n\n验证Python程序的运行环境\n\nimport platform\nprint(\"platform = \",platform.python_version())\n\n\n"
        },
        {
          "title": "MySql 安装",
          "url": "/RoadToExcellence/PythonEnvironment.html#mysql-安装",
          "content": "MySql 安装\n安装mysql数据库：\n下载链接\n安装步骤\n\n\n查看mysql进程是否存在\nps aux | grep mysql\n\n\n\n测试数据库\n\n\nmysql 默认安装在 /usr/local/mysql，该目录下有对应的bin、lib、doc等目录\ncd /usr/local/mysql && ls\n\n\n\n在bin目录下，执行 ./mysql -u root -p ，输入安装时设置的初始化密码，即可看到mysql版本信息和mysql命令行界面\ncd bin && ./mysql -u root -p \n\n\n\n\n\n配置环境变量\nopen ~/.bash_profile\n\n文件最后新起一行，插入下面两行代码\nexport PATH=$PATH:/usr/local/mysql/bin\nexport PATH=$PATH:/usr/local/mysql/support-files\n\n\n\n操作数据库（命令行）\n\n\n启动MySQL服务12\nsudo mysql.server start\n\n\n\n停止MySQL服务\nsudo mysql.server stop\n\n\n\n重启MySQL服务\nsudo mysql.server restart\n\n\n\n查看MySQL服务状态\nsudo mysql.server status\n\n\n\n进入MySQL\nmysql -u root -p\n\n\n\n修改root密码（必须修改，否则将来莫名报错）\nALTER USER 'root'@'localhost' IDENTIFIED BY 'sai'; \n\n\n\n退出MySQL\nexit\n\n\n错误： ERROR! MySQL server PID file could not be found!  参考方案\n\n重启 sql：系统偏好设置 - MySQL\n\n\n\n\n\n"
        }
      ]
    },
    {
      "title": "Python入门导读Python面向对象",
      "content": "!/usr/bin/python#!/usr/bin/pythonprint(\"Hello, World!\")\n#!/usr/bin/python 是告诉操作系统执行这个脚本时，调用 /usr/bin 下的 python 解释器，相当于写死了 python 路径。\n注释# 第一种注释方式 '''\n第二种注释方式\n第二种注释方式\n'''\n1.对象 = 静态属性 + 动态方法\n2.Python 中的类名约定以大写字母开头\n最简单的类封装：类可以封装 属性 和 方法\nclass Turtle():\n    '''__doc__ 是类描述，写在第一行'''\n    # 属性\n    mouth = 'Turtle 的大嘴'\n    \n    # 方法\n    def climb(self):\n        print(\"Turtle 在向前爬......\")\n\nturtleA = Turtle()\nturtleA.climb()\nprint(turtleA.mouth)\nprint(turtleA.__doc__)\n继承：子类继承父类的所有属性和方法后，增加新的 属性 和 方法\nclass GreenTurtle(Turtle):\n    # 新增属性\n    color = 'GreenTurtle 是绿色'\n    \n    # 新增方法\n    def eat(self):\n        print(\"GreenTurtle 在吃绿藻\")\n\nturtleB = GreenTurtle()\nturtleB.climb()\nprint(GreenTurtle.mouth)\nturtleB.eat()\nprint(GreenTurtle.color)\n属性名称的命名规则\n_name：没有任何约束，约定该属性只在类内部使用，虽然不建议但可以任性的在类外部用 ._name 的形式访问\nname_：没有任何约束，只是在 name 与保留字冲突时这么用，比如 BeautifulSoup 中访问 class 时，要用 class_\n__name：有约束，双下划线会被解释器修改为_.__name\n__name__：尽量不要用\n_：单独一个下划线，表示一个临时用一用，以后都不会被用到，非常无关紧要的变量，用完即扔，完全可以不关注\n\nfor _ in range(5):    print('Hello, World.')\ncar = ('red', 'auto', 12, 3812.4)color, _, _, mileage = car\nprint(color)\nprint(mileage)\n最小空类\n作用：通过动态增加属性，管理临时数据\n\nclass Tiny_Empty_Class:    pass\n\nt = Tiny_Empty_Class()\nprint(f'初始时 t.__dict__是 {t.__dict__}')\nt.name = 'will'\nt.age = 30\nt.family = {'bro':'超','papa':'山'}\nprint(f'动态增加属性后 t.__dict__是 {t.__dict__}')\n实例方法class Student():\n    def talk(self, *args):\n        print(f'我是实例方法 args:{args}')\n\nUX_Stu = Student()\nUX_Stu.talk('MAP')\n1.实例方法 第一个参数必须是 self\n2.实例方法 只有1种调用方式\n\n1..()\n\n类方法 @classmethodclass Student():\n    @classmethod\n    def talk(cls, *args):\n        print(f'我是类方法 args:{args}')\n\nUX_Stu = Student()\nUX_Stu.talk('MAP')\nStudent.talk('MAP')\n1.类方法 第一个参数必须是 cls\n2.类方法 可以有2种调用方式\n\n1..()\n2..()\n\n静态方法 @staticmethodclass Student():\n    @staticmethod\n    def talk(*args):\n        print(f'我是静态方法 args：{args}')\n\nUX_Stu = Student()\nUX_Stu.talk('MAP')\nStudent.talk('MAP')\n1.静态方法 不需要 self 和 cls，随便用什么参数\n2.静态方法 可以有2种调用方式\n\n1..()\n2..()\n\n_init_() 构造方法\ninit 前后各2个下划线\n类实例化时会自动调用 _init_()，\n\nclass Turtle():    \n    # 方法\n    def __init__(self, name):\n        self.name = name\n\n    def kick(self):\n        print(f\"Turtle {self.name} 被踢了...\")\n\nturtleA = Turtle('小黄')\nturtleA.kick()\n私有属性和私有方法\n私有属性__private_attrs：两个下划线开头，只能在类内部的方法中以self.__private_attrs方式使用，不能在类外部使用。\n私有方法__private_method：两个下划线开头，只能在类内部以self.__private_methods方式调用，不能在类外部调用。\n\n多重继承class Name_Class:    def __init__(self, name):\n        self.__name = name\n    def printName(self):\n        return self.__name\n\nclass Nick_Class:\n    def __init__(self, nick):\n        self.__nick = nick\n    def printName(self):\n        return self.__nick + ' 同志'\n\nclass Name_Nick_Class(Name_Class, Nick_Class):\n    def printName(self):\n        print(f'{super().printName()} 你好')\n\nclass Nick_Name_Class(Nick_Class, Name_Class):\n    def printName(self):\n        print(f'{super().printName()} 你好')\n\np1 = Name_Nick_Class('Will')\np1.printName()\n\np2 = Nick_Name_Class('Sai')\np2.printName()\n\nsuper() 按照深度优先，从左至右的方式寻找基类方法\n\n重载import time\nclass Fish:\n    def myMethod(self):\n        self.time = time.time()\n        print (f'调用父类方法的时间 {self.time}')\n \nclass Shark(Fish):\n    def myMethod(self):\n        super().myMethod()\n        print (f'调用子类方法的时间 {self.time}')\n\nBaby_Shark = Shark()\nBaby_Shark.myMethod()\n\nsuper() 方法能调用父类的方法\n要使用父类的属性，必须调用super() 方法\n\n多态class Animal(object):    def run(self):\n        print('Animal is running...')\n\nclass Dog(Animal):\n    def run(self):\n        print('Dog is running fast...')\n\nclass Cat(Animal):\n    def run(self):\n        print('Cat is running softly...')\n\ndef run_twice(animal):\n    animal.run()\n    animal.run()\n\nrun_twice(Dog())\nrun_twice(Cat())\n多态真正的威力：调用方只管调用，不管细节，如果我们要新增一个 Animal 的子类 Tortoise 时，只要确保正确重载 run() 方法，原来的代码不需要任何改动\nclass Tortoise(Animal):    def run(self):\n        print('Tortoise is running slowly...')\n\nrun_twice(Tortoise())\n从方法中返回方法def hi(name=\"will\"):    def greet():\n        return \"这是 greet() 方法\"\n \n    def welcome():\n        return \"这是 welcome() 方法\"\n \n    if name == \"will\":\n        return greet\n    else:\n        return welcome\n \na = hi()\nprint('print a 打印的是:',a)\nprint('print a() 打印的是:',a())\n\nb = hi(name = \"sai\")()\nprint('print b 打印的是:',b)\n运行结果print a 打印的是: .greet at 0x10f7acf28>print a() 打印的是: 这是 greet() 方法\nprint b 打印的是: 这是 welcome() 方法\n在 if/else 返回 greet 和 welcome，而不是 greet() 和 welcome()。是因为greet 和 welcome 有小括号时，函数就会执行；而没有小括号时，它可以被到处传递，并且可以赋值给别的变量而不去执行它。当我们写下 a = hi()，由于 name 参数默认是 yasoob，那么函数 greet 将被返回。当我们写下 b = hi(name = \"ali\")，那么函数 welcome 将被返回。\n当我们写下 b = hi(name = \"ali\")()，那么函数 welcome() 将被返回。可变参数 *args\n*args：形参名前加一个*，参数被存放在元组 tuple 中\n\ndef argsFunc(*args):\tprint(my_args)\n\t\nargsFunc(1, 2, 3, 4)\nargsFunc()\n可变参数 **kwargs\n**kwargs：形参名前加两个*，参数被存放在字典 dictionary 中，调用方法需要采用 arg1 = value1, arg2 = value2 这样的形式\n\ndef argsFunc(**kwargs):\tprint(my_args)\n\t\nargsFunc(x=1, y=2, z=3)\nargsFunc()\nattr三兄弟（hasattr、getattr、setatter）hasattr：判断是否包含属性\ngetattr：获取属性值\nsetatter：设置属性值\nclass Turtle():\n    color = 'black'\n    \n    def __init__(self, name):\n        self.name = name\n\n    def Turtle_info(self):\n        print(f\"Turtle 的名字是{self.name}, 颜色是{self.color}\")\n\nturtleA = Turtle('小黄')\n\nprint(hasattr(turtleA,'color'))\nprint(getattr(turtleA,'color'))\nsetattr(turtleA,'color','green')\nprint(getattr(turtleA,'color'))\nproperty() 函数\nproperty(get_attr, set_attr, del_attr, '属性描述')可以操作属性值\nget_attr, set_attr, del_attr 最好符合这种格式，前半部分是 get, set, del 中间是一个下划线'_',后半部分的属性名\n若只有get_attr，则属性为只读，不能写不能删，若只有get_attr, set_attr，则属性为可读可写，不能删，等等\n\nclass Student():\n    def __init__(self, name):\n        '''初始化方法'''\n        self.__name = name\n        self.__score = 0\n\n    def __str__(self):\n        return f'我的姓名是{self.__name}，分数是{self.__score}'\n\n    def get_score(self):\n        return self.__score\n\n    def set_score(self, value):\n        if not isinstance(value, int):\n            raise ValueError('分数必须是整型')\n        if value  100:\n            raise ValueError('分数区间必须是 0 ~ 100!')\n        self.__score = value\n\n    def del_score(self):\n        print('删除了 score 属性')\n        del self.__score\n\n    score = property(get_score, set_score, del_score, \"有关余额操作的属性\")\n\nwill = Student(\"sai\")\nprint(will)\n\nwill.score = 500\nprint(will.score)\n\nprint(Student.score.__dict__)\n\ndel will.score\nprint(will.score)\n\n对象.score 会调用get_score方法\n对象.score=值 会调用set_score方法\ndel 对象.score 会调用del_score方法\n.属性名.doc 会打印'属性描述'\n由于 get_score() 方法中需要返回 score 属性，如果使用 self.score 的话，其本身又被调用 get_score()，这将进入无限死循环。为了避免这种情况的出现，程序中的 score 属性必须设置为私有属性，即使用 __score（前面有 2 个下划线）\n\n@property 装饰器 替代 property() 函数class Student(object):\n    def __init__(self, name):\n        '''初始化方法'''\n        self.__name = name\n        self.__score = 0\n\n    def __str__(self):\n        return f'我的姓名是{self.__name}，分数是{self.__score}'\n        \n    @property\n    def score(self):\n        return self.__score\n\n    @score.setter\n    def score(self, value):\n        if not isinstance(value, int):\n            raise ValueError('分数必须是整型')\n        if value  100:\n            raise ValueError('分数区间必须是 0 ~ 100!')\n        self.__score = value\n\n    @score.deleter\n    def score(self):\n        print('删除了 score 属性')\n        del self.__score\n\nwill = Student(\"sai\")\nprint(will)\n\nwill.score = 500\nprint(will.score)\n\nprint(Student.score.__dict__)\n\ndel will.score\nprint(will.score)\n@classmethod 装饰器class Student():    def eat(self, x):\n        print(f\"{x} 一个人吃饭 {self}\")\n\n    @classmethod\n    def class_eat(cls, x):\n        print(f\"{x} 班级聚餐 {cls}\")\n   \na = Student()\na.eat('will')\na.class_eat('Map')\nStudent.class_eat('Map')\n\n@classmethod 修饰类方法，一般用不到\n必须包含 cls 参数\n\n@装饰器语法def 装饰器名(func):    @functools.wraps(func)\n    def wrapper(*args, **kwargs):\n        print('call %s():' % func.__name__)\n        return func(*args, **kwargs)\n    return wrapper\n\ndef 装饰器(text):\n    @functools.wraps(func)\n    def decorator(func):\n        def wrapper(*args, **kwargs):\n            print(f'{text},{func.__name__}')\n            return func(*args, **kwargs)\n        return wrapper\n    return decorator\n\n作用：扩展方法的功能\n场景：下面的备份代码，想在不修改原有代码的前提下，增加一个打印备份时间的功能\n@functools.wraps(func) 能保留原函数的名称，不懂\n\n示例 1import functools,datetime\ndef BackUpLog(func):\n    @functools.wraps(func)\n    def wrapper(*args, **kwargs):\n        CurrentTime = datetime.datetime.now().strftime(\"%Y.%m.%d %H:%M:%S\")\n        print(f'数据备份时间是 {CurrentTime}')\n        return func(*args, **kwargs)\n    return wrapper\n\n@BackUpLog\ndef BackUp():\n    print('备份已完成')\n\nBackUp()\n分析：装饰器BackUpLog 的作用是，把在BackUp() 方法前面插入一些新的代码\n@BackUpLog 就是下面代码的简写\nBackUp = BackUpLog(BackUp)示例 2import functools,time,random\ndef TimeCost(func):\n    @functools.wraps(func)\n    def wraper(*args, **kwargs):\n        before = time.time()\n        result = func(*args, **kwargs)\n        after = time.time()\n        print(f\"BackUp()方法耗时: {after-before}\")\n        return result\n    return wraper\n\n@TimeCost\ndef BackUp():\n    time.sleep(random.random())\n    print('备份已完成')\n    \nBackUp()\n分析：装饰器TimeCost 的作用是，把在BackUp() 方法前后插入一些新的代码\n@TimeCost 就是下面代码的简写\nBackUp = TimeCost(BackUp)示例 3import functools\ndef bread(func):\n    @functools.wraps(func)\n    def wrapper():\n        print(\"\")\n        func()\n        print(\"\")\n    return wrapper\n\ndef ingredients(func):\n    @functools.wraps(func)\n    def wrapper():\n        print(\"#tomatoes#\")\n        func()\n        print(\"~  salad  ~\")\n    return wrapper\n\n@bread\n@ingredients\ndef sandwich(food=\"--Hamburg--\"):\n    print(food)\n\nsandwich()\n运行结果#tomatoes#\n--Hamburg--\n~  salad  ~\n\n小模块：打印实例及其类的所有属性__dict__class Print_AttrValues_Instance_Class():\n    '''打印实例及其类的所有属性和属性值'''\n\n    def Get_Key_Value_Instance(self,instance):\n        print(f'\\n{\"*\"*10}实例的__dict__{\"*\"*10}')\n        \n        for each_key,each_value in instance.__dict__.items():\n            print(each_key,'：',each_value)\n        \n        print(f'\\n{\"*\"*35}')\n\n    def Get_Key_Value_Class(self,instance):\n        print(f'\\n{\"*\"*10}类的__dict__{\"*\"*10}')\n        \n        for each_key,each_value in type(instance).__dict__.items():\n            print(each_key,'：',each_value)\n        \n        print(f'\\n{\"*\"*35}')\n\n    def Get_Key_Value_Instance_Class(self,instance):\n        self.Get_Key_Value_Instance(instance)\n        self.Get_Key_Value_Class(instance)\n\nclass Student():\n\n    def eat(self, x):\n        print(f\"{x} 一个人吃饭 {self}\")\n   \nwill = Student()\nwill.talk = 'Hi BaiDu'\nprintValues = Print_AttrValues_Instance_Class()\nprintValues.Get_Key_Value_Instance_Class(will)\n",
      "url": "/RoadToExcellence/PythonBasicTutorial.html",
      "children": [
        {
          "title": "等待用户输入",
          "url": "/RoadToExcellence/PythonBasicTutorial.html#等待用户输入",
          "content": "等待用户输入sentence = input(\"输入一句话：\")print(\"你输入的话是：\",sentence)\n运行结果输入一句话：i love the world你输入的话是： i love the world\n测试程序清空shellimport osinput(\"\")\nos.system('clear')\n格式化字符串 f-stringf-string 格式化字符串以 f 开头，变量用大括号 {} 包起来，它会将变量或表达式计算后的值替换进去name = 'Runoob'print(f'Hello {name}')\nprint(f'1 + 3 = {1+3}')\n运行结果Hello Runoob1 + 3 = 4\n运算符\n\n运算符\n描述\n实例\n\n\n\n\n/\n正常除法\n5/3=1.667\n\n\n//\n取整\n5//3=1\n\n\n%\n取余\n5%3=2\n\n\n**\n次幂\n5**3=125\n\n\nx and y\n与运算\n(True and False)返回False\n\n\nx or y\n或运算\n(True or False)返回True\n\n\nnot x\n非运算\n(not False)返回True\n\n\nin\n包含关系\n('a' in ('a','b'))返回True\n\n\nnot in\n包含关系\n('a’ not in ('a','b'))返回False\n\n\nis\n判断两个变量是否引用同一个对象\n\n\n\nis not\n判断两个变量是否引用同一个对象\n\n\n\n"
        },
        {
          "title": "end关键字",
          "url": "/RoadToExcellence/PythonBasicTutorial.html#end关键字",
          "content": "end关键字end实现不换行效果a, b = 0, 1while b < 1000:\n    print(b, end=',')\n    a, b = b, a+b\n运行结果1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,标准数据类型不可变类型：Number（int, float）、String（str）、Tuple（tuple）\n可不类型：List（列表）、Set（set）、Dictionary（dict）\n类型判断方法：type()，isinstance()\nstring、list 和 tuple 都属于 sequence（序列），都可以遍历\nString（字符串）str='12345abcde'\n# 第1个参数 -1 表示倒数第1个字符\n# 第2个参数为空，表示移动到列表末尾\n# 第3个参数为步长，负号表示逆向\nprint(\"str[-1::-1] =\",str[-1::-1])\nprint(\"str[-1::-2] =\",str[-1::-2])\nprint(\"str[0] =\",str[0])               # 输出第1个字符\nprint(\"str[5:] =\",str[5:])              # 输出从第6个开始后的所有字符\nprint(\"str[:5] =\",str[:5])              # 输出从第1个开始到第6个字符，不包含第6个\nprint(\"str[2:5] =\",str[2:5])             # 输出从第3个开始到第6个的字符，不包含第6个\nprint(\"str[5:-2] =\",str[5:-2])            # 输出从第6个到倒数第3个字符\n运行结果str[-1::-1] = edcba54321str[-1::-2] = eca42\nstr[0] = 1\nstr[-1] = e\nstr[5:] = abcde\nstr[:5] = 12345\nstr[2:5] = 345\nstr[5:-2] = abc\nList（列表）TypeList = [2, 2.2, 'will', (1,'a','a'), [1,'a','a'], {1,'a','a'}, {'1st': 1,'2nd':'a', '3rd':'a'}]\nprint('TypeList[1:4]是：',TypeList[1:4])\nfor element in TypeList:\n    print(str(element) + ' 的类型是：'+str(type(element))+' '+str(isinstance(element, type(element))))\n运行结果TypeList[1:4]是： [2.2, 'will', (1, 'a', 'a')]2 的类型是： True\n2.2 的类型是： True\nwill 的类型是： True\n(1, 'a', 'a') 的类型是： True\n[1, 'a', 'a'] 的类型是： True\n{1, 'a'} 的类型是： True\n{'1st': 1, '2nd': 'a', '3rd': 'a'} 的类型是： True\nTuple（元组）TypeTuple = (2, 2.2, 'will', (1,'a','a'), [1,'a','a'], {1,'a','a'}, {'1st': 1,'2nd':'a', '3rd':'a'})\nprint('TypeTuple[1:4]是：',TypeTuple[1:4])\nfor element in TypeTuple:\n    print(str(element) + ' 的类型是：'+str(type(element))+' '+str(isinstance(element, type(element))))\n运行结果TypeTuple[1:4]是： (2.2, 'will', (1, 'a', 'a'))2 的类型是： True\n2.2 的类型是： True\nwill 的类型是： True\n(1, 'a', 'a') 的类型是： True\n[1, 'a', 'a'] 的类型是： True\n{1, 'a'} 的类型是： True\n{'1st': 1, '2nd': 'a', '3rd': 'a'} 的类型是： True\nSet（集合）1.会自动去重，不包含重复元素\n2.作用：成员测试，去重复\nTypeSet = {'Tom', 'Tom', 'Jack', 'Rose'}\n# 输出集合，去重复\nprint(\"{'Tom', 'Tom', 'Jack', 'Rose'}集合自动去重：\",TypeSet)\n \n# 成员测试\nif 'Rose' in TypeSet :\n    print('Rose 在集合中')\nelse :\n    print('Rose 不在集合中')\n \n# set可以进行集合运算\na = set('abracadabra')\nb = set('alacazam')\n\nprint('a：',a)     # a 去重复\nprint('b：',b)     # b 去重复\nprint('a - b：',a - b)     # a 和 b 的差集\nprint('a | b：',a | b)     # a 和 b 的并集\nprint('a & b：',a & b)     # a 和 b 的交集\nprint('a ^ b：',a ^ b)     # a 和 b 中不同时存在的元素\n运行结果{'Tom', 'Tom', 'Jack', 'Rose'}集合自动去重： {'Tom', 'Rose', 'Jack'}Rose 在集合中\na： {'r', 'b', 'd', 'c', 'a'}\nb： {'l', 'z', 'm', 'c', 'a'}\na - b： {'d', 'r', 'b'}\na | b： {'r', 'b', 'l', 'd', 'z', 'm', 'c', 'a'}\na & b： {'c', 'a'}\na ^ b： {'d', 'z', 'm', 'r', 'l', 'b'}\n集合的基本操作\n\nTypeSet.add('Will')\n添加元素\n\n\n\n\nTypeSet.remove('Jack')\n删除元素\n\n\nlen(TypeSet)\n计算元素个数\n\n\nTypeSet.clear()\n清空集合\n\n\n'Will' in TypeSet\n判断存在\n\n\nDictionary（字典）TypeDic = {'1st': 1,'2nd':'a', '3rd':'a'}\nprint (\"TypeDic['2nd']是：\",TypeDic['2nd'])\nprint (TypeDic.keys())   # 输出所有键\nprint (TypeDic.values())   # 输出所有键\n\nfor DicKey,DicValue in TypeDic.items():\n    print(DicKey,'的值是：',DicValue)\n运行结果TypeDic['2nd']是： adict_keys(['1st', '2nd', '3rd'])\ndict_values([1, 'a', 'a'])\n1st 的值是： 1\n2nd 的值是： a\n3rd 的值是： a\n方法（字典）不定长参数 *vartuple\ndef printinfo( arg, *varTuple ):   print ('参数 arg 是：', arg,'; 参数 varTuple 是：', varTuple)\n   return\n \nprintinfo(10)\nprintinfo(70, 60, 50)\n运行结果参数 arg 是： 10 ; 参数 varTuple 是： ()参数 arg 是： 70 ; 参数 varTuple 是： (60, 50)\n不定长参数 **varDict\ndef printinfo( arg, **varDict ):   print ('参数 arg 是：', arg,'; 参数 varDict 是：', varDict)\n   return\n\nprintinfo(1)\nprintinfo(1, a=2,b=3)\n运行结果参数 arg 是： 1 ; 参数 varDict 是： {}参数 arg 是： 1 ; 参数 varDict 是： {'a': 2, 'b': 3}\nlambda 表达式\nCac = lambda arg1, arg2: (arg1 + arg2)*2 \nprint (\"计算后的值: \", Cac( 10, 20 ))\nprint (\"计算后的值: \", Cac( 20, 20 ))\n运行结果计算后的值:  60计算后的值:  80\n列表推导式\nmyList = [2, 4, 6]\nprint('[3*x for x in myList] 的结果是:', [3*x for x in myList])\nprint('[3*x for x in myList if x > 3] 的结果是:', [3*x for x in myList if x > 3])\nprint('[[x, x**2] for x in myList] 的结果是:', [[x, x**2] for x in myList])\n\nyourList = [4, 3, -9]\nprint('[x+y for x in myList for y in yourList] 的结果是:',[x+y for x in myList for y in yourList])\nprint('[myList[i]*yourList[i] for i in range(len(myList))] 的结果是:',[myList[i]*yourList[i] for i in range(len(myList))])\n运行结果[3*x for x in myList] 的结果是: [6, 12, 18][3*x for x in myList if x > 3] 的结果是: [12, 18]\n[[x, x**2] for x in myList] 的结果是: [[2, 4], [4, 16], [6, 36]]\n[x+y for x in myList for y in yourList] 的结果是: [6, 5, -7, 8, 7, -5, 10, 9, -3]\n[myList[i]*yourList[i] for i in range(len(myList))] 的结果是: [8, 12, -54]\n嵌套列表解析\nmatrix = [[1, 2, 3, 4],\n[5, 6, 7, 8],\n[9, 10, 11, 12],\n]\n\nprint('矩阵转置后：',[[row[i] for row in matrix] for i in range(4)])\n运行结果矩阵转置后： [[1, 5, 9], [2, 6, 10], [3, 7, 11], [4, 8, 12]]del删除语句\na = [-1, 1, 66.25, 333, 333, 1234.5]del a[0]\nprint('del a[0]的结果：',a)\ndel a[2:4]\nprint('del a[2:4]的结果：',a)\ndel a[:]\nprint('del a[:]的结果：',a)\n运行结果del a[0]的结果： [1, 66.25, 333, 333, 1234.5]del a[2:4]的结果： [1, 66.25, 1234.5]\ndel a[:]的结果： []\n__name__属性\n一个模块 myModule.py 被另一个模块 yourModule.py 第一次引入时，其主程序将运行。如果想在模块被引入时，模块中的某一程序块不执行，可以用__name__属性来使该程序块仅在该模块自身运行时执行# Filename: myModule.py\nif __name__ == '__main__':\n   print('程序自身在运行')\nelse:\n   print('我来自另一模块')\n运行结果# 直接运行 myModule.py 时程序自身在运行\n# 从另一个模块 yourModule.py 调用myModule.py 时\n我来自另一模块\ndir() 方法\ndir() 可以找到模块内定义的所有名称print(dir(list))运行结果['__add__', '__class__', '__contains__', '__delattr__', '__delitem__', '__dir__', '__doc__', '__eq__', '__format__', '__ge__', '__getattribute__', '__getitem__', '__gt__', '__hash__', '__iadd__', '__imul__', '__init__', '__init_subclass__', '__iter__', '__le__', '__len__', '__lt__', '__mul__', '__ne__', '__new__', '__reduce__', '__reduce_ex__', '__repr__', '__reversed__', '__rmul__', '__setattr__', '__setitem__', '__sizeof__', '__str__', '__subclasshook__', 'append', 'clear', 'copy', 'count', 'extend', 'index', 'insert', 'pop', 'remove', 'reverse', 'sort']pickle 模块import pickle\n# 使用pickle模块将数据对象保存到文件\nOriginalData = {'a': [1, 2.0, 3, 4+6j],\n         'b': ('string', u'Unicode string'),\n         'c': None}\n\nselfref_list = [1, 2, 3]\nselfref_list.append(selfref_list)\n\nwith open('/Users/jiangsai02/Documents/Temp/myPickle.pkl', 'wb') as OpenPickle:\n    pickle.dump(OriginalData, OpenPickle)\n    pickle.dump(selfref_list, OpenPickle, -1)\n\nwith open('/Users/jiangsai02/Documents/Temp/myPickle.pkl', 'rb') as OpenPickle:\n    GetData = pickle.load(OpenPickle)\n    print(GetData)\n异常\t try    ├── 执行代码\texcept  ├── 有异常时执行的代码\n\t else   ├── 没有异常时执行的代码\n\tfinally ├── 有没有异常都会执行的代码\ntry:    print('这是try里的代码')\nexcept AssertionError as error:\n    print('except AssertionError 的异常内容：',error)\nelse:\n    try:\n        with open('file.log') as file:\n            read_data = file.read()\n    except FileNotFoundError as fnf_error:\n        print('except FileNotFoundError 的异常内容：',fnf_error)\nfinally:\n    print('有没有异常都会执行的代码')\n运行结果这是try里的代码except FileNotFoundError 的异常内容： [Errno 2] No such file or directory: 'file.log'\n有没有异常都会执行的代码\n强制抛异常\nraise：有时为了满足需求，即便没有运行错误，也要人为抛出异常\nraise之后的代码不会执行\n\ntry:    num = input(\"输入一个小于10的数：\")\n    if(not num.isdigit()):\n        raise ValueError(\"num 必须是数字\")\n        print('raise 之后的代码不会执行')\n    else:\n        if(int(num) > 10):\n            raise ValueError(\"num 必须小于10\")\n            print('raise 之后的代码不会执行')\nexcept ValueError as e:\n    print(\"引发异常：\",repr(e))\n自定义的异常\n必须继承 Exception\n\nclass DemoException(Exception):\n    def __init__(self, name, msg = '自定义的 Demo 异常'):\n        self.__name = name\n        self.__msg = msg\n\n    def __str__(self):\n        return (f'{self.__name} 异常的报警是 {self.__msg}')\n\ntry:\n    raise DemoException('脚本错误')\nexcept DemoException as e:\n    print(e)\n"
        }
      ]
    },
    {
      "title": "flask 入门",
      "content": "",
      "url": "/RoadToExcellence/FlaskBasicTutorial.html",
      "children": [
        {
          "title": "安装 flask 环境",
          "url": "/RoadToExcellence/FlaskBasicTutorial.html#安装-flask-环境",
          "content": "安装 flask 环境查看虚拟环境： conda info --envs\n创建虚拟环境 conda create -n flask_py3 python=3.7\n激活虚拟环境： source activate flask_py3\n安装flask： pip install flask\n安装 Flask-WTF 表单插件： pip install Flask-WTF\n安装 flask-sqlalchemy 数据库抽象插件：pip install flask-sqlalchemy\n安装 flask-mysqldb 数据库插件：pip install pymysql\n安装MySQL 数据库插件：pip install cryptography\n查看环境下所有包 conda list\n配置 VS Code 环境设置\n\nsetting.json : \"python.pythonPath\": \"/Users/jiangsai02/opt/anaconda3/envs/flask_py3/bin/python\"\n\n\nrequirements.txt\n\npython项目中必须包含一个 requirements.txt 文件，用于记录所有依赖包及其精确的版本号，以便新环境部署\n在本机的虚拟环境下使用pip生成\npip freeze >requirements.txt\n将 requirements.txt 文件拷贝到部署机器的虚拟目录下，进入文件所在目录，进入虚拟环境，安装全部依赖\ncd /Users/jiangsai02/opt/anaconda3/envs/flask_py3\nsource activate flask_py3\npip install -r requirements.txt\n\n\nFlask 调试切记！！！: app.run(debug=False) 一定不能开启调试！否则无法命中断点\nlanuch.json是debug相关的配置文件\n\"stopOnEntry\": true 进入程序时立即暂停执行，相当于在程序的第一行放一个断点\n\n\n\"configurations\": [\n   {\n       \"name\": \"Python: Current File (Integrated Terminal)\",\n       \"type\": \"python\",\n       \"request\": \"launch\",\n       \"program\": \"${file}\",\n       \"console\": \"integratedTerminal\",\n       \"stopOnEntry\": true,\n   },\n\n\n\n切记！！！ ：Flask在启动时必须指定 app.run(debug=False)，一定不能开启调试！否则无法命中断点\n\nif __name__ == '__main__':\n    app.run(debug = False)\n\n\n\n监视变量\nDebug 时有两种方式监视变量\n variables (变量窗口) 会默认显示当前 scope 内的 local 变量的值\n watch (监视窗口) 是用户自己输入的表达式，因此不仅限于变量的值，还可以监视变量的变化\n\n\n\n参考\n\n\n一个最小的应用：返回字符串from flask import Flask\napp = Flask(__name__)\n\n@app.route('/', methods = ['GET', 'POST'])\ndef hello_world():\n    return 'Hello Flask Sai!'\n\n@app.route('/')\ndef get_order_id(order_id):\n    print(f'Your order ID Type : {type(order_id)}')\n    return f'Your order ID : {order_id}'\n\nif __name__ == '__main__':\n    app.run(debug = True)\n剖析\n创建Flask 应用程序实例\n\n\napp = Flask(__name__)\n\n\n__name__的作用是确定资源所在路径\n\n\n\n定义路由及视图函数\n\n\n@app.route('/', methods = ['GET', 'POST'])\ndef hello_world():\n    return 'Hello Flask Sai!'\n\n\n用 app 变量的 route() 装饰器来告诉 Flask 框架，哪些 URL 触发哪些视图函数\n如 对路径 '/' 的请求，将触发对 hello_world() 函数的调用\n如 对路径 '/' 的请求，将触发对 get_order_id() 函数的调用\n路由默认只支持 GET 请求，可用 methods = [] 自行扩展\n\n@app.route('/')\ndef get_order_id(order_id):\n    return f'Your order ID : {order_id}'\n\n\n使用同一个视图函数 get_order_id() 显示不同用户的订单信息\n格式：1.  2. get_order_id(路由参数)\n\n\n\n启动程序\n\n\nif __name__ == '__main__':\n    app.run(debug = True)\n\n\napp.run()将 Flask 运行到一个 Flask 提供的简易测试服务器上\ndebug = True 启动调试模式，每次修改代码后服务自动重启\napp.run(port = 8888, debug = True) 可将 Web 服务默认监听本地的 5000 端口修改为监听 8888 端口，即 http://127.0.0.1:8888/\n\n\n一个最小的应用：返回网页创建一个基本的 Flask 目录结构\n├── ~/Documents/Temp/SaiFlask/    ├── app.py\n    ├── templates/\n        ├── index.html\n        └── HelloYou.html\n    └── static/\n        ├── TeddyBear.jpg\n\n\n目录\n描述\n\n\n\n\napp.py\n主程序\n\n\ntemplates\n存放模板文件\n\n\nstatic\n存放静态文件，如图片，音频，视频，JS文件以及样式文件\n\n\n1_Index.html\nHello Sample\n{% if name %}\n    Hello {{ name }}!\n{% else %}\n    Hello World!\n{% endif %}\n2_CodeBlock.html\nHello CodeBlock\nMovieList 是 {{ MovieList }}，共计 {{ MovieList | length }} 部电影 \n电影列表是 \n{% for movie in MovieList %}\n    {{ movie.title }} - {{ movie.year }} \n{% endfor %}\n\nNumList 是 {{ NumList }}，共计 {{ NumList | length }} 个数 \n小于 10 的数是 \n{% for num in NumList %}\n    {% if num \n    {% endif %}\n{% endfor %}\n3_Filter.html\nHello Filter\n\n百度的网址：{{BaiduUrl}} \n字符串大写：{{BaiduUrl | upper }} \n字符串反转：{{BaiduUrl | reverse | upper }} \n4_OriginalWebForm\n\n    用户名： \n    密码： \n    确认密码： \n    \n\n5_FlashWebForm.html\n\n    用户名： \n    密码： \n    确认密码： \n    \n    {% for message in get_flashed_messages() %}\n        {{ message }}\n    {% endfor %}\n\n6_FlaskWTForm.html\n\n    {{ login_form_web.csrf_token() }}\n    {{ login_form_web.username.label }}{{ login_form_web.username }} \n    {{ login_form_web.password.label }}{{ login_form_web.password }} \n    {{ login_form_web.password2.label }}{{ login_form_web.password2 }} \n    {{ login_form_web.submit }} \n    {% for message in get_flashed_messages() %}\n        {{ message }}\n    {% endfor %}\n\napp.py\nfrom flask import Flaskfrom flask import render_template\nfrom flask import request\nfrom flask import flash\nfrom flask_wtf import FlaskForm\nfrom wtforms import StringField, PasswordField, SubmitField\nfrom wtforms.validators import EqualTo, DataRequired\n\napp = Flask(__name__)\n\napp.secret_key = 'The secret string for encryption'\n\n@app.route('/')\n@app.route('/')\ndef Index(name = None):\n    return render_template('1_Index.html', name = name)\n\n@app.route('/cb')\ndef CodeBlock():\n    MovieList = [\n    {'title': 'My Neighbor Totoro', 'year': '1988'},\n    {'title': 'Dead Poets Society', 'year': '1989'},\n    {'title': 'A Perfect World', 'year': '1993'},\n    ]\n    NumList = [1, 3, 5, 7, 9, 11, 13]\n    return render_template('2_CodeBlock.html', NumList = NumList, MovieList = MovieList)\n\n@app.route('/f')\ndef Filter():\n    BaiduUrl = 'https://www.baidu.com/'\n    return render_template('3_Filter.html', BaiduUrl = BaiduUrl)\n\n@app.route('/ot', methods = ['GET', 'POST'])\ndef OriginalWebForm():\n    if request.method == 'POST':\n        username = request.form.get('username')\n        password = request.form.get('password')\n        password2 = request.form.get('password2')\n        print(f'你输入的用户：{username}，密码：{password}，确认密码：{password2}')\n        if not all([username, password, password2]):\n            result = '参数不完整'\n        elif password != password2:\n            result = '两次输入的密码不同'\n        else:\n            result = 'POST 成功了, Yeah'\n        return result\n    return render_template('4_OriginalWebForm.html')\n\n@app.route('/ft', methods = ['GET', 'POST'])\ndef FlashWebForm():\n    if request.method == 'POST':\n        username = request.form.get('username')\n        password = request.form.get('password')\n        password2 = request.form.get('password2')\n        print(f'FlashWebForm 用户名：{username}，密码：{password}，确认密码：{password2}')\n        if not all([username, password, password2]):\n            flash('参数不完整')\n        elif password != password2:\n            flash('两次输入的密码不同')\n        else:\n            return 'FlashWebForm 成功了, Yeah'\n    return render_template('5_FlashWebForm.html')\n\nclass LoginForm(FlaskForm):\n    username = StringField('用户名', validators = [DataRequired()])\n    password = PasswordField('密码', validators = [DataRequired()])\n    password2 = PasswordField('确认密码', validators = [DataRequired(), EqualTo('password', '密码不一致')])\n    submit = SubmitField('提交')\n\n@app.route('/fwt', methods = ['GET', 'POST'])\ndef FlaskWTForm():\n    login_form = LoginForm()\n    print(f'FlaskWTForm 用户名：{login_form.username.data}, 密码：{login_form.password.data}, 确认密码：{login_form.password2.data}')\n    print(f'FlaskWTForm 用户名：{login_form.data[\"username\"]}, 密码：{login_form.data[\"password\"]}, 确认密码：{login_form.data[\"password2\"]}')\n    if login_form.validate_on_submit():\n        return 'FlaskWTForm 成功了, Yeah'\n    else:\n        flash(login_form.errors)\n    return render_template('6_FlaskWTForm.html', login_form_web = login_form)\n\nif __name__ == '__main__':\n    app.run(debug = True)\n剖析2_CodeBlock.html\nmyList 是 {{ myList }}，而小于 10 的是\n{% for num in myList %}\n {% if num \n {% endif %}\n{% endfor %}\n\n\n{% %} 表示控制代码块\n{{ }} 表示 HTML 的变量代码块\n\n3_Filter.html\n百度的网址：{{BaiduUrl}} \n字符串大写：{{BaiduUrl | upper }} \n字符串反转：{{BaiduUrl | reverse | upper }} \n\n\n过滤器格式：变量名 | 过滤器 {{ variable | filter_name(*args) }}\n过滤器的链式调用，即拼接多个过滤器 {{ variable | filter_name(*args) | filter_name(*args) }}\n\n5_FlashWebForm.html\n{% for message in get_flashed_messages() %}\n    {{ message }}\n{% endfor %}\n\n\nget_flashed_messages() 方法接受后端传来的 flash 消息\n\n6_FlaskWTForm.html\n\n\n    {{ login_form_web.csrf_token() }}\n    {{ login_form_web.username.label }}{{ login_form_web.username }} \n    {{ login_form_web.password.label }}{{ login_form_web.password }} \n    {{ login_form_web.password2.label }}{{ login_form_web.password2 }} \n    {{ login_form_web.submit }} \n    {% for message in get_flashed_messages() %}\n        {{ message }}\n    {% endfor %}\n\n\n\nWTForms默认开启CSRF保护，所以必须有这段代码 ..csrf_token()\n\nfrom flask import render_template\n\n@app.route('/')\n@app.route('/')\ndef Index(name = None):\n return render_template('1_Index.html', name = name)\n\n\n渲染模板需要导入 render_template\n对路径 '/' 的请求，将触发对 Index() 函数的调用\n对路径 '/' 的请求，将触发对 Index() 函数的调用， 是任意 str\nrender_template('1_Index.html') 将渲染 templates 目录下的 1_Index.html 模板\n模板 1_Index.html 中的变量名和 app.py 中的变量保持一致，即 name = name\n\n@app.route('/cb')\ndef CodeBlock():\n    myList = [1, 3, 5, 7, 9, 11, 13]\n    return render_template('2_CodeBlock.html', myList = myList)\n\n\n对路径 '/cb' 的请求，将触发对 CodeBlock() 函数的调用\n\nfrom flask import request\n\n@app.route('/t', methods = ['GET', 'POST'])\ndef OriginalWebForm():\n    if request.method == 'POST':\n        username = request.form.get('username')\n        password = request.form.get('password')\n        password2 = request.form.get('password2')\n        print(f'你输入的用户：{username}，密码：{password}，确认密码：{password2}')\n        if not all([username, password, password2]):\n            result = '参数不完整'\n        elif password != password2:\n            result = '两次输入的密码不同'\n        else:\n            result = 'POST 成功了, Yeah'\n        return result\n    return render_template('4_OriginalWebForm.html')\n\n\n获取前端的上传请求消息，需要导入 request 模块\n表单上传是 'POST' 方式\n路由通过 request.method 判断请求方式：'GET', 'POST' 。必须大写\n路由通过 request.form.get() 从前端获取请求的参数\n\nfrom flask import flash\n\napp.secret_key = 'The secret string for encryption'\n\n@app.route('/ft', methods = ['GET', 'POST'])\ndef FlashWebForm():\n    if request.method == 'POST':\n        username = request.form.get('username')\n        password = request.form.get('password')\n        password2 = request.form.get('password2')\n        print(f'你输入的用户：{username}，密码：{password}，确认密码：{password2}')\n        if not all([username, password, password2]):\n            flash('参数不完整')\n        elif password != password2:\n            flash('两次输入的密码不同')\n        else:\n            return 'POST 成功了, Yeah'\n    return render_template('5_FlashWebForm.html')\n\n\n从后端向前端传递消息，要导入 flash 模块\n通过 secret_key 给后端的消息加密\n\nfrom flask_wtf import FlaskForm\n\nfrom wtforms import StringField, PasswordField, SubmitField\n\nfrom wtforms.validators import EqualTo, DataRequired\n\nclass LoginForm(FlaskForm):\n    username = StringField('用户名', validators = [Required()])\n    password = PasswordField('密码', validators = [Required()])\n    password2 = PasswordField('确认密码', validators = [Required(), EqualTo('password', '密码不一致')])\n    submit = SubmitField('提交')\n\n@app.route('/fwt', methods = ['GET', 'POST'])\ndef FlaskWTForm():\n    login_form = LoginForm()\n    print(f'FlaskWTForm 用户名：{login_form.username.data}, 密码：{login_form.password.data}, 确认密码：{login_form.password2.data}')\n    print(f'FlaskWTForm 用户名：{login_form.data[\"username\"]}, 密码：{login_form.data[\"password\"]}, 确认密码：{login_form.data[\"password2\"]}')\n    if login_form.validate_on_submit():\n        return 'FlaskWTForm 成功了, Yeah'\n    else:\n        flash(login_form.errors)\n    return render_template('6_FlaskWTForm.html', login_form_web = login_form)\n\n\n使用 Flask-WTF 验证表单数据\n\n\n\n安装Flask-WTF： pip install Flask-WTF\nStringField 文本字段\nPasswordField 密码文本字段\nSubmitField 表单提交按钮\nEqualTo 验证函数，比较两个字段的值\nDataRequired 验证函数，确保字段中有数据\n\n\n\n替代 request.method == 'POST' ，验证 FlaskForm 表单是否提交\n\n\n\n方法：validate_on_submit()\n\n\n\n获取 FlaskForm 属性值的两种方式\n\n\n\nlogin_form.username.data\nlogin_form.data[\"username\"]\n\n\n一个最小的应用：使用数据库from flask import Flaskfrom flask_sqlalchemy import SQLAlchemy\n\napp = Flask(__name__)\n\napp.config['SQLALCHEMY_DATABASE_URI'] = 'mysql+pymysql://root:sai@127.0.0.1/sql_demo'\napp.config['SQLALCHEMY_TRACK_MODIFICATIONS'] = True\nmyDB = SQLAlchemy(app)\n\nclass Role(myDB.Model):\n    __tablename__ = 'DB_Role'\n    id = myDB.Column(myDB.Integer, primary_key=True)\n    name = myDB.Column(myDB.String(64))\n    users = myDB.relationship('User', backref='role')\n\n    def __repr__(self):\n        return f'{self.name}'\n\nclass User(myDB.Model):\n    __tablename__ = 'DB_User'\n    id = myDB.Column(myDB.Integer, primary_key=True)\n    name = myDB.Column(myDB.String(64), unique=True, index=True)\n    role_id = myDB.Column(myDB.Integer, myDB.ForeignKey('DB_Role.id'))\n\n    def __repr__(self):\n        return f'{self.name}'\n\nif __name__ == '__main__':\n    myDB.drop_all()\n    myDB.create_all()\n\n    # 增\n    ro1 = Role(name='管理员')\n    ro2 = Role(name='用户')\n    myDB.session.add_all([ro1, ro2])\n    myDB.session.commit()\n\n    us1 = User(name='小李', role_id=ro1.id)\n    us2 = User(name='小欣', role_id=ro2.id)\n    us3 = User(name='小曲', role_id=ro1.id)\n    myDB.session.add_all([us1, us2, us3])\n    myDB.session.commit()\n\n    userlist = myDB.session.query(User)\n    for each_user in userlist:\n        print(f'User id: {each_user.id} | User name: {each_user.name} | User role_id: {each_user.role_id} | User role: {each_user.role}')\n    \n    rolelist = myDB.session.query(Role)\n    for each_role in rolelist:\n        print(f'Role id: {each_role.id} | Role name: {each_role.name} | Role users: {each_role.users}')\n\n    # 改\n    us1.name = 'sai'\n    us2.name = 'chao'\n    myDB.session.commit()\n\n    # 删\n    myDB.session.delete(us1)\n    myDB.session.commit()\n\n    app.run(debug=False, port = 8888)\n剖析\n首先安装 MySQL 数据库\n\n\n\n详情查看 PythonEnvironment.md\n\n\n\n\n设置连接数据库的URL\napp.config['SQLALCHEMY_DATABASE_URI'] = 'mysql+pymysql://root:sai@127.0.0.1/sql_demo'\n\n\n\n数据库协议：mysql+pymysql（不可变）\n用户名：root（可改为其他用户名）\n用户名密码：sai\n服务器地址：127.0.0.1 或 localhost\n数据库名：sql_demo\n\n\n\n\n设置每次请求结束后会自动提交数据库的改动（为降低消耗资源，可设为False）\napp.config['SQLALCHEMY_TRACK_MODIFICATIONS'] = True\n\n\n\n通过类 SQLAlchemy 来连接数据库\nmyDB = SQLAlchemy(app)\n\n\n\n定义角色类 Role 都继承数据库模型 myDB.Model\n\n\n\n定义 Role 在数据库中的表名\n__tablename__ = 'roles'\n\n\n\n定义 id 为整数型，为主键\nid = myDB.Column(myDB.Integer, primary_key=True)\n\n\n\n定义 name 为字符型，最大 64 个字符\nname = myDB.Column(myDB.String(64))\n\n\n\n关于 relationship 的用法**（不懂，但是完全不影响，可以不使用）**\nclass Role(myDB.Model):\n    __tablename__ = 'DB_Role'\n    id = myDB.Column(myDB.Integer, primary_key=True)\n    name = myDB.Column(myDB.String(64))\n    users = myDB.relationship('User', backref='role')\n\n    def __repr__(self):\n        return f'{self.name}'\n\nclass User(myDB.Model):\n    __tablename__ = 'DB_User'\n    id = myDB.Column(myDB.Integer, primary_key=True)\n    name = myDB.Column(myDB.String(64), unique=True, index=True)\n    role_id = myDB.Column(myDB.Integer, myDB.ForeignKey('DB_Role.id'))\n\n    def __repr__(self):\n        return f'{self.name}'\n\n\n\n\n声明数据库 DB_Role 表的表名：__tablename__ = 'DB_Role'\n\n\n声明数据库 DB_Role 表的字段：id ,  name\n\n\nid ,  name 是数据库 DB_Role 表的字段，而 user 不是字段，users 是为方便查询虚拟存在的。myDB.Column() 声明字段，myDB.relationship() 声明关系\nid = myDB.Column()\nname = myDB.Column()\nusers = myDB.relationship()\n\n\n\n第一步，给 Role 模型 增加一个 users 属性，并与 User 模型建立关联\nusers = myDB.relationship('User')\n\n\n\n第二步，给 User 模型 增加一个 role 属性，并与 Role 模型建立关联\nusers = myDB.relationship('User', backref='role')\n\n\n\n声明了上面这一句代码，就相当于：给 Role 模型 增加一个 users 属性，同时给 User 模型 增加一个 role 属性。 Role 模型 中的一句代码给 User 模型 增加了一个属性，很神奇\n\n\n用法\nuserlist = myDB.session.query(User)\nfor each_user in userlist:\n    print(f'User id: {each_user.id} | User name: {each_user.name} | User role_id: {each_user.role_id} | User role: {each_user.role}')\n\nrolelist = myDB.session.query(Role)\nfor each_role in rolelist:\n    print(f'Role id: {each_role.id} | Role name: {each_role.name} | Role users: {each_role.users}')\n\n\n\nUser 模型的 each_user.role 取的是 __repr__的值\nRole 模型的 each_role.users 取的是 __repr__的值\n\n\n\n\n\n\n\n\n\n\n定义用户类 User 继承数据库模型 myDB.Model\n\n\n\n定义 name 为字符型，值唯一unique，为本字段创建索引index\nname = myDB.Column(myDB.String(64), unique=True, index=True)\n\n\n\n定义 role_id 为整数型，为主键，将 role_id 设为 roles 表中 id 字段的外键，即 外键主表是 roles 表，子表 users 表\nrole_id = myDB.Column(myDB.Integer, myDB.ForeignKey('roles.id'))\n\n外键的作用\n\n\n\n完整性：即向子表 users 表插入数据时会检查 role_id 的值在主表 roles 表中是否存在，若不存在，则插入失败。\n例如 roles 表有 '1', '2' 两个值，向子表 users 表插入数据 us3 = User(name = 'liuwei', role_id = 3)，则插入失败，因为 roles 表没有 '3' 这个值\n\n\n\n\n\n\n\n\n设置数据库\n\n\n\n进入数据库\nmysql -u root -p\n\n\n\n创建数据库，并使用它\ncreate database sql_demo;\nuse sql_demo;\nshow tables;\n\n\n\n\n\n\n在操作数据库\n\n\n删除所有表：myDB.drop_all()\n创建所有表：myDB.create_all()\n加入 session ：myDB.session.add_all([, ])\n提交 session ：myDB.session.commit()\n删除实例：myDB.session.delete()\n\n\n\n\n"
        }
      ]
    },
    {
      "title": "爬虫入门",
      "content": "",
      "url": "/RoadToExcellence/WebCrawlerGetStart.html",
      "children": [
        {
          "title": "BeautifulSoup 学习",
          "url": "/RoadToExcellence/WebCrawlerGetStart.html#beautifulsoup-学习",
          "content": "BeautifulSoup 学习conda list 查看当前环境，没安装beautifulsoup4，requests\nsource activate jspython3\npip install beautifulsoup4\npip install requests\n\n第一个BeautifulSoup示例\nimport requests\nfrom bs4 import BeautifulSoup\n\nhtml_doc = \"\"\"\nThe Dormouse's story\n\nThe Dormouse's storyAnother story\nOnce upon a time there were three little sisters; and their names were\nElsie,\nLacie and\nTillie;\nand they lived at the bottom of a well.\n...\n\"\"\"\n\nsoup = BeautifulSoup(html_doc, \"html.parser\")\n# 把HTML源码用解释器html.parser格式化一下\n\nHTML以标签对开始，标签对结束\nBeautifulSoup将HTML转成标签树，标签树的每个节点都是Python的对象\nBeautifulSoup基本元素\n\nTag：即标签，最基本的信息组织单元，分别用和标明开头和结尾\nComment：即标签内字符串的注释部分，一种特殊的Comment类型\nName：获取标签的名字，...的名字是'p'。\n\n用法：.name\n\n\nAttributes：获取标签的属性，字典的形式组织。\n\n用法：.attrs\n\n\nNavigableString：获取标签内非属性字符串，...中的字符串。\n\n用法：.string\n\n\n\n\n常用方法\n\n.find()\n\nsoup.find('a')\n\n获取源码中第一个...标签内容对象\n\n\nsoup.find('a', id='next')\n\n获取源码中第一个有属性为id，值为next的对象，比如...。\n\n\n注1：属性id、src、name都可以这么用，唯独class这个属性因为是Python关键字，不能直接使用，要用 class_ 进行代替，如soup.find('a', class_ = 'next')\n注2：find返回的结果，依然可以继续使用find()或者find_all()方法\n\n\n.find_all()\n\nsoup.find_all('a')\n\n获取源码中所有的...标签内容对象\n\n\nsoup.find_all('a', id='next')\n\n获取源码中所有包含属性为id，值为next的对象，比如...。\n\n\n注1：find_all返回的结果，依然可以继续使用find()或者find_all()方法\n注2：find_all返回的结果很大时，可以用limit参数限制返回结果的数量，适用于测试时soup.find('a', class_ = 'next', limit = 2)\n\n\n.string\n\n获取标签的文本字符串\n\n\n\n\nprint('soup.prettify() = ',soup.prettify())\nprint('soup.title = ',soup.title)\nprint('soup.title.name = ',soup.title.name)\nprint('soup.title.string = ',soup.title.string)\nprint('soup.title.text = ',soup.title.text)\nprint('soup.title.parent.name = ',soup.title.parent.name)\nprint('soup.p = ',soup.p)\nprint('soup.p[\"class\"] = ',soup.p[\"class\"])\nprint('soup.a = ',soup.a)\nprint('soup.a.string = ',soup.a.string)\nprint('soup.a.attrs = ',soup.a.attrs)\nprint('soup.a.attrs[\"href\"] = ',soup.a.attrs['href'])\nprint('soup.find_all(\"a\") = ',soup.find_all('a'))\nprint('soup.find(id=\"link3\") = ',soup.find(id='link3'))\n\n运行结果\nsoup.title =  The Dormouse's story\n# 即soup中的title标签的全部内容\n# 全部内容包含标签，属性，文本，及子孙节点的标签，属性，文本\n\nsoup.title.name =  title\n# 即soup中的title标签的名字\n\nsoup.title.string =  The Dormouse's story\n# 即soup中的title标签的文本字符串\n\nsoup.title.parent.name =  head\n# 即soup中的title标签的父节点的名字\n\nsoup.p =  The Dormouse's storyAnother story\n# 即soup中的第一个p标签的全部内容\n# 全部内容包含标签，属性，文本，及子孙节点的标签，属性，文本\n\nsoup.p[\"class\"] =  ['title']\n# 即soup中的第一个p标签的'class'属性的内容\n\nsoup.a =  Elsie\n# 即soup中的第一个a标签的全部内容\n# 全部内容包含标签，属性，文本，及子孙节点的标签，属性，文本\n\nsoup.a.string =  Elsie\n# 即soup中的第一个a标签的文本\n\n> soup.a.text =  Elsie\n# 即soup中的第一个a标签的文本，与soup.a.string一样\n\nsoup.a.attrs =  {'href': 'http://example.com/elsie', 'class': ['sister'], 'id': 'link1'}\n# 即soup中的第一个a标签的字典\n\nsoup.a.attrs[\"href\"] =  http://example.com/elsie\n# 即soup中的第一个a标签的字典中key为\"href\"的值\n\nsoup.find_all(\"a\") =  [Elsie,  href=\"http://example.com/lacie\" id=\"link2\">Lacie,  id=\"link3\">Tillie]\n# 即soup中的所有a标签的全部内容的列表\n# 全部内容包含标签，属性，文本，及子孙节点的标签，属性，文本\n\nsoup.find(id=\"link3\") =  Tillie\n# 即soup中id=\"link3\"所在标签的全部内容\n# 全部内容包含标签，属性，文本，及子孙节点的标签，属性，文本\n\n下行遍历：从当前节点向子孙节点遍历\n\n.contents：获取全部儿子节点的全部内容的列表（全部内容包含标签，属性，文本，及子孙节点的标签，属性，文本）\n.children：获取儿子节点的迭代类型，用于遍历\n.descendants：获取子孙节点的迭代类型，用于遍历\n\n注：.contents和.children只获得当前节点的下一层节点的信息，而.descendants可获得当前节点后续的所有节点的信息\n\n\n\n\nprint('soup.body = ',soup.body)\nprint('soup.body.contents = ',soup.body.contents)\n\nnum = 1\nprint('soup.body.children = ')\nfor child in soup.body.children:\n    print(\"第\" + str(num) + \"个儿子：\" , child)\n    num += 1\n\nnum = 1\nprint('soup.body.descendants = ')\nfor descendant in soup.body.descendants:\n    print(\"第\" + str(num) + \"个子孙：\" , descendant)\n    num += 1\n\n运行结果\nsoup.body =  \n\nThe Dormouse's storyAnother story\nOnce upon a time there were three little sisters; and their names were\nElsie,\nLacie and\nTillie;\nand they lived at the bottom of a well.\n...\n\n# 获取整个……的全部内容\n# 全部内容包含标签，属性，文本，及子孙节点的标签，属性，文本\n\nsoup.body.contents =  \n['\\n', The Dormouse's storyAnother story, '\\n', Once upon a > time there were three little sisters; and their names were\nElsie,\nLacie and\nTillie;\nand they lived at the bottom of a well., '\\n', ..., '\\n']\n# 获取标签的全部儿子节点的全部内容的列表\n# 儿子节点的全部内容包含标签，属性，文本，及子孙节点的标签，属性，文本\n\nsoup.body.children = \n第1个儿子： \n第2个儿子： The Dormouse's story\n第3个儿子： \n第4个儿子： Once upon a time there were three little sisters; and their names were\nElsie,\nLacie and\nTillie;\nand they lived at the bottom of a well.\n第5个儿子： \n第6个儿子： ...\n第7个儿子： \n# 获取标签的全部儿子节点的内容\n# 儿子节点的全部内容包含标签，属性，文本，及子孙节点的标签，属性，文本\n\nsoup.body.descendants = \n第1个子孙： \n第2个子孙： The Dormouse's storyAnother story\n第3个子孙： The Dormouse's story\n第4个子孙： The Dormouse's story\n第5个子孙： Another story\n第6个子孙： Another story\n第7个子孙： \n第8个子孙： Once upon a time there were three little sisters; and their names were\nElsie,\nLacie and\nTillie;\nand they lived at the bottom of a well.\n第9个子孙： Once upon a time there were three little sisters; and their names were\n第10个子孙： Elsie\n第11个子孙： Elsie\n第12个子孙： ,\n第13个子孙： Lacie\n第14个子孙： Lacie\n第15个子孙：  and\n第16个子孙： Tillie\n第17个子孙： Tillie\n第18个子孙： ;\nand they lived at the bottom of a well.\n第19个子孙： \n第20个子孙： ...\n第21个子孙： ...\n第22个子孙：  \n# 获取标签的全部子孙节点，首先获取第1个儿子节点的全部内容，然后进入第1个儿子节点获取第一个孙子节点，直到没有下级节点后，获取同级的孙子节点及其下级节点，同级遍历结束后返回上级节点\n# 子孙节点的全部内容包含标签，属性，文本，及子孙节点的标签，属性，文本\n\n上行遍历：从当前节点向父祖节点遍历\n\n.parent：获取当前节点的父节点标签的全部内容（全部内容包含标签，属性，文本，及子孙节点的标签，属性，文本）\n.parents：获取当前节点的父祖节点标签的全部内容的迭代类型\n目前不知用处\n\n\nfor parent in soup.a.parents:\n    if parent is None:\n        print('soup.a.parent = ',parent)\n    else:\n        print('soup.a.parent.name = ',parent.name)\n\n运行结果\nsoup.a.parent.name =  p\nsoup.a.parent.name =  body\nsoup.a.parent.name =  html\nsoup.a.parent.name =  [document]\n\n平行遍历：同一父节点下的子节点遍历\n\n.next_sibling：获取同一父节点下的下一个兄弟节点标签\n.previous_sibling：获取同一父节点下的上一个兄弟节点标签\n.next_siblings：迭代类型，获取同一父节点下的所有后续兄弟节点标签\n.previous_siblings：迭代类型，获取同一父节点下的所有前续兄弟节点标签\n目前不知用处\n\n\nfor sibling in soup.a.next_siblings:\n    print('soup.a.next_sibling = ',sibling)\n运行结果\nsoup.a.next_sibling =  ,\nsoup.a.next_sibling =  Lacie\nsoup.a.next_sibling =   and\nsoup.a.next_sibling =  TillieAnother > story\nsoup.a.next_sibling =  ;\nand they lived at the bottom of a well.\n\n"
        },
        {
          "title": "爬虫之BeautifulSoup解析豆瓣即将上映的电影信息",
          "url": "/RoadToExcellence/WebCrawlerGetStart.html#爬虫之beautifulsoup解析豆瓣即将上映的电影信息",
          "content": "爬虫之BeautifulSoup解析豆瓣即将上映的电影信息目的：获取豆瓣电影页面电影列表的名字、详情链接、上映时间、影片类型、地区、关注者数量\n原教程\n思路1. 分析网页这一步非常重要，直接影响了我们能不能提取到我们想要的内容。\n找到网页中的第一个电影的名字，鼠标指向该名字，点击右键，选择\"检查\"，页面上会打开\"开发者工具\"窗口，焦点会定位到电影名字\n当鼠标划到图片中的...标签的时候，\"复仇者联盟\"的详细信息被选中了。\n当鼠标划到下一个...的时候，下一个影片\"战犬瑞克斯\"的所有信息被选中了。\n当鼠标划到图片上方的的时候，整个网页中我们需要采集的影片信息都被选中了。\n这几个动作说明1.我们需要的内容全都在...里面。\n2.每个影片的信息，都在一个...或者...里面。画面左边的影片没有odd属性，右边的有odd属性(这好像对于我们采集信息没啥用)。\n2. 制订提取策略先找到囊括了所有的影片的最大的div\n再从最大的div里找到每一个影片的div\n最后从每个影片的div里面解析出来我们需要的名字、链接等等信息\n从上图得知目标位置\n\n电影属性\n源码中的位置\n\n\n\n\n电影名\n在第 2 个标签里面\n\n\n链接\n在第 1 个和第 2 个标签的 href 属性里面\n\n\n上映日期\n在第 1 个标签里面\n\n\n类型\n在第 2 个标签里面\n\n\n地区\n在第 3 个标签里面\n\n\n关注者数量\n在第 4 个标签里面\n\n\n3. 获取目标内容方式电影名：先获取所有的标签，再取第二个标签的 text\n链接：利用上一步获取的所有标签，取第二个标签的href属性\n其他信息：先获取所有的标签，再依次取出里面的text的值就是我们所需要的目标，上映日期，类型，地区等等\n源码及分析import requestsfrom bs4 import BeautifulSoup\n\ndef GetSoup(url):\n    fake_headers = {\n    'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/79.0.3945.79 Safari/537.36'\n    }\n    response = requests.get(url, headers=fake_headers)\n    html = response.content.decode('utf-8')\n    soup = BeautifulSoup(html, 'html.parser')\n    return soup\n\ndef GetBigData(soup):\n    all_movies = soup.find('div', id=\"showing-soon\")\n    bigData = []\n    for each_movie in all_movies.find_all('div', class_=\"item\", limit = 2):\n        data = Data()\n        # 先获取所有的标签\n        all_a_tag = each_movie.find_all('a')\n        # 再取第二个标签的 text，即电影名\n        data.movie_name = all_a_tag[1].text\n        # 再取第二个标签的 'href'属性，即电影链接\n        data.moive_href = all_a_tag[1]['href']\n\n        # 先获取所有的标签\n        all_li_tag = each_movie.find_all('li')\n        # 再取第二个标签的 text，即日期\n        data.movie_date = all_li_tag[0].text\n        data.movie_type = all_li_tag[1].text\n        data.movie_area = all_li_tag[2].text\n        data.movie_lovers = all_li_tag[3].text\n        #print(f'名字：{data.movie_name}\\n 链接：{data.moive_href}\\n 日期：{data.movie_date}\\n 类型：{data.movie_type}\\n 地区：{data.movie_area}\\n 关注者：{data.movie_lovers}\\n')\n        bigData.append(data)\n    return bigData\n\ndef PrintBigData(bigData):\n    for data in bigData:\n        print(f'名字：{data.movie_name}\\n 链接：{data.moive_href}\\n 日期：{data.movie_date}\\n 类型：{data.movie_type}\\n 地区：{data.movie_area}\\n 关注者：{data.movie_lovers}\\n')\n\nif __name__ == \"__main__\":\n    url = \"https://movie.douban.com/cinema/later/chengdu/\"\n    soup = GetSoup(url)\n    bigData = GetBigData(soup)\n    PrintBigData(bigData)\n\n\n伪装成浏览器的header\nfake_headers = {\n    'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/79.0.3945.79 Safari/537.36'\n}\n\n\n\n先找到囊括了所有的影片的最大的div\nall_movies = soup.find('div', id=\"showing-soon\")\nprint(all_movies)\n\n\n\n再从最大的div里找到每一个影片的div\nfor each_movie in all_movies.find_all('div', class_=\"item\", limit = 2):\n    print(\"电影信息：\\n\",each_movie)\n    # 先获取所有的标签\n    all_a_tag = each_movie.find_all('a')\n    # 再取第二个标签的 text，即电影名\n    movie_name = all_a_tag[1].text\n    # 再取第二个标签的 'href'属性，即电影链接\n    moive_href = all_a_tag[1]['href']\n\n    # 先获取所有的标签\n    all_li_tag = each_movie.find_all('li')\n    # 再取第二个标签的 text，即日期\n    movie_date = all_li_tag[0].text\n    movie_type = all_li_tag[1].text\n    movie_area = all_li_tag[2].text\n    movie_lovers = all_li_tag[3].text\n\n\n\n源码中 class 的值有 \"item mod odd\" 和 \"item mod\"，tag的 class 属性是多值属性，可以分别搜索tag中的每个CSS类名，如class_=\"item\",class_=\"mod\",class_=[\"item\",\"mod\"]\n\n\n\n\nimport requestsfrom bs4 import BeautifulSoup\nimport csv\n\n# 空类的作用是存数据\nclass Data():\n    pass\n\ndef GetSoup(url):\n    fake_headers = {\n    'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/79.0.3945.79 Safari/537.36'\n    }\n    response = requests.get(url, headers=fake_headers)\n    html = response.content.decode('utf-8')\n    soup = BeautifulSoup(html, 'html.parser')\n    return soup\n\ndef GetBigData(soup):\n    all_movies = soup.find('div', id=\"showing-soon\")\n    bigData = []\n    for each_movie in all_movies.find_all('div', class_=\"item\", limit = 2):\n        data = Data()\n        # 先获取所有的标签\n        all_a_tag = each_movie.find_all('a')\n        # 再取第二个标签的 text，即电影名\n        data.movie_name = all_a_tag[1].text\n        # 再取第二个标签的 'href'属性，即电影链接\n        data.moive_href = all_a_tag[1]['href']\n\n        # 先获取所有的标签\n        all_li_tag = each_movie.find_all('li')\n        # 再取第二个标签的 text，即日期\n        data.movie_date = all_li_tag[0].text\n        data.movie_type = all_li_tag[1].text\n        data.movie_area = all_li_tag[2].text\n        data.movie_lovers = all_li_tag[3].text\n        bigData.append(data)\n    return bigData\n\ndef PrintBigData(bigData):\n    for data in bigData:\n        print(f'名字：{data.movie_name}\\n 链接：{data.moive_href}\\n 日期：{data.movie_date}\\n 类型：{data.movie_type}\\n 地区：{data.movie_area}\\n 关注者：{data.movie_lovers}\\n')\n\ndef WriteToTxt(bigData):\n    with open('/Users/jiangsai02/Documents/Temp/WebCrawler.txt', 'w') as OpenTxt:\n        for data in bigData:\n            for each_key,each_value in data.__dict__.items():\n                OpenTxt.write(f'{each_key}\":\"{each_value}\\n')\n            OpenTxt.write('\\n')\n\ndef WriteToHtml(bigData):\n    html_begin = (\"\"\"\n                \n                \n                \n                    \n                    豆瓣电影即将上映影片信息\n                    \n                \n                \n                豆瓣电影即将上映影片信息\n                \n                    \n                        \n                            影片名\n                            上映日期\n                            影片类型\n                            地区\n                            关注者数量\n                        \n                    \n                    \n                \"\"\")\n    html_end = (\"\"\"\n                    \n                \n                \n                \n                \"\"\")\n    def each_movie_info(data):\n        movie_info = (f\"\"\"\n                        \n                            {data.movie_name}\n                            {data.movie_date}\n                            {data.movie_type}\n                            {data.movie_area}\n                            {data.movie_lovers}\n                        \n                    \"\"\")\n        return movie_info\n    with open('/Users/jiangsai02/Documents/Temp/WebCrawler.html', 'w') as OpenHtml:\n        OpenHtml.write(html_begin)\n        for data in bigData:\n            html_movie_info = each_movie_info(data)\n            OpenHtml.write(html_movie_info)\n        OpenHtml.write(html_end)\n\ndef WriteToCSV(bigData):\n    # Windows默认编码是gbk，如果用utf-8，excel打开可能会乱码\n    # newline='' 是为了让writer自动添加的换行符和文件的不重复，防止出现跳行的情况\n    with open('/Users/jiangsai02/Documents/Temp/WebCrawler.csv', 'w', encoding=\"gbk\", newline='') as OpenCSV:\n        CSVwriter = csv.writer(OpenCSV)\n        CSVwriter.writerow([\"影片名\", \"链接\", \"上映日期\", \"影片类型\", \"地区\", \"关注者\"])\n        for data in bigData:\n            CSVwriter.writerow([data.movie_name, data.moive_href, data.movie_date, data.movie_type, data.movie_area, data.movie_lovers])\n\nif __name__ == \"__main__\":\n    url = \"https://movie.douban.com/cinema/later/chengdu/\"\n    soup = GetSoup(url)\n    bigData = GetBigData(soup)\n    PrintBigData(bigData)\n    WriteToTxt(bigdata)\n    WriteToHtml(bigdata)\n    WriteToCSV(bigData)\n\n\nGetSoup(url)：网页转换成 BeautifulSoup 对象\n\n这是个通用方法，以后直接用即可\n\n\n\nGetBigData(soup)：从 BeautifulSoup 对象中获取目的数据\n\n这是整个程序的关键，具体分析可往上翻分析策略\n\n\n\nPrintBigData(bigData)：打印目的数据，判断是否遗漏\n\n\nWriteToTxt(bigdata)：写入txt\n\n\nWriteToHtml(bigdata)：写入html\n\nhtml 的拼接可以借鉴\n\n\n\nWriteToCSV(bigData)：写入csv\n\n\n"
        },
        {
          "title": "爬虫之读写",
          "url": "/RoadToExcellence/WebCrawlerGetStart.html#爬虫之读写",
          "content": "爬虫之读写import requestsfrom bs4 import BeautifulSoup\n\n# 伪装成浏览器的header\nurl = \"https://python123.io/ws/demo.html\"\n# 请求参数里面把伪装的header加上\nfake_headers = {\n    'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/79.0.3945.79 Safari/537.36'\n}\n\nresponse = requests.get(url, headers=fake_headers)\nhtml = response.content.decode('utf-8')\nsoup = BeautifulSoup(html, 'html.parser')\nprint(soup)\n1.写操作，写入时覆盖原文# 自动关闭文件with open('/Users/jiangsai02/Documents/Temp/WebCrawler.html', 'w') as OpenHtml:\n    OpenHtml.write(response.content.decode('utf-8'))\n2.读操作# 自动关闭文件with open('/Users/jiangsai02/Documents/Temp/WebCrawler.html', 'r', encoding=\"utf-8\") as OpenHtml:\n    Html = OpenHtml.read()\n"
        }
      ]
    },
    {
      "title": "PM BaiDu学习",
      "content": "2020-1-10\n1.PM 输入用户需求，输出可立项的项目\n\n1.1 每一期的项目必须非常明确，中间插入的高优需求可以作为短期现象单独列出来，低优需求放到下一期\n\n2.RD 通过立项来研发验证PM 的设计\n\n2.1 PM 通过每日站会来跟踪RD 进展\n\n2020-1-19\n1.主持站会\n\n1.1 进入http://newicafe.baidu.com/\n1.2 选择左侧\"迭代管理\"\n1.3 选择\"Plan Track\"，最新的Plans，如\"1.13-1.17\"\n1.4 选择\"Filter\"过滤\n1.5 选择\"lastModifiedTime\"最后更改为00:00:00 - 23:59:59\n1.6 点击右上角Track，切换到看板模式\n\n",
      "url": "/RoadToExcellence/PMwork.html",
      "children": []
    },
    {
      "title": "杂记",
      "content": "final cut Pro 用法导出方式\n文件 - 共享 - Apple 设备 1080P - 设置\n修改2个地方\n\n格式：电脑\n完成时：什么都不做\n\n",
      "url": "/RoadToExcellence/Uncategorized.html",
      "children": []
    }
  ]
}